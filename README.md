# Java OOP

## Семинар 2

**Задача 1.1**

Создать package data. Работу проводить в нем
Создать абстрактный класс User и его наследники Student и Teacher родитель имеет в себе общие данные (фио, год рождения, паспорт (серия и номер)), а наследники - собственные параметры (номер группы для Student, кафедра для Teacher)

**Задача 1.2**

Создать package util. Работу проводить в нем
Создать классы WriterToTxt и ReaderFromTxt, имеющие статичные методы для записи/чтения в/из txt.файла

**Задача 1.3**

Создать package service. Работу проводить в нем
Создать интерфейс DataService, описывающий реализацию конкретных сервисов по управлению сущностями (create, read).
Создать для сущности Student отдельный Service, реализующий интерфейс DataService.
Create и read операции реализуются путем вызова utils методов

**Задача 2**

Создать package view. Работу проводить в нем.
Создать абстрактный класс или интерфейс UserView, содержащий в себе метод void showTheBest(List <User> userList),
внутри вызывающий абстрактный метод User findTheBest(List <User> userList) и распечатывающий результат.
Создать класс StudentView, унаследованный от UserView, содержащий в себе реализацию findTheBest.

**Задача 3**
  
Создать package controller
Создать класс Controller, содержащий в себе необходимые интерфейсы в виде переменных, а в конструкторе создать объекты конкретных реализаций.
Создать метод createStudent (Student), реализующий логику путем вызова соответствующих методов интерфейсов:
* Создание студента;
* Запись в файл студента;
* Чтение того, что записали;
* Возвращение в методе того, что прочли в файле


## Домашнее задание (семинар 2)
  
1. Создать класс StudentGroup, содержащая в себе поля Teacher и список студентов.
2. Создать класс StudentGroupServiceImpl, в котором реализована логика чтения Студентов и Преподавателя из файла txt
(реализация чтения файла опциональна), создания класса StudentGroup и возвращения его.
3. Создать метод в Controller createGroup(int groupNumber), в который передается номер группы, а возвращается StudentGroup.
4. Все вышеуказанное создать согласно принципам ООП пройдённым на семинаре.


## Семинар 3

**Задача 1**
  
1. Создать класс StudentGroupIterator, заставив его реализовать интерфейс Iterator <Student>.
2. Реализовать его абстрактные метод.
3. Реализовать метод remove()
  
**Задача 2**
  
1. Модифицировать класс StudentGroup, заставив его реализовать интерфейс Iterable<Student>
2. Реализовать метод iterator() возвращающий экземпляр созданного нами итератора
3. Модифицировать класс StudentGroupServiceImpl, добавив в него метод удаления студента по ФИО
4. Модифицировать класс Controller, добавив в него метод удаления студента и вызывать в нем созданный метод из StudentGroupServiceImpl

**Задача 3**
  
1. Модифицировать класс Student, заставив его реализовать интерфейс Comparable
2. Реализовать контракт compareTo () со сравнением по году рождения студента
3. Модифицировать класс StudentGroupServiceImpl, добавив в него метод сортировки списка студентов
4. Модифицировать класс Controller, добавив в него метод сортировки списка студентов и вызывать в нем созданный метод из StudentGroupServiceImpl

**Задача 4**
  
1. Создать класс UserComparator реализующий интерфейс Comparator<User>
2. Реализовать контракт compareTo() со сравнением по ФИО
3. Модифицировать класс StudentGroupServiceImpl, добавив в него метод сортировки списка студентов по ФИО
4. Модифицировать класс Controller, добавив в него метод сортировки списка студентов по ФИО и вызывать в нем созданный метод из StudentGroupServiceImpl


## Семинар 4

**Задача 1**
  
* Создать пекедж repository. Дальнейшие работы ведем в нем
* Реализовать в нем интерфейс Repository<E,I>
* Задать в созданном интерфейсе 2 абстрактных метода:
E save(E entity)
E findById (I id)
* Создать класс GroupRepository, имплементировав его от Repository

**Задача 2**

* Создать класс GroupRepository имплементировав его от Repository<Group, Integer>
* В классе StudentGroupServiceImpl добавить новую переменную Repository<Group, Integer>
* В классе StudentGroupServiceImpl  реализовать методы сохранения группы и поиска её по номеру 

**Задача 3**

* Создать интерфейс UserRepository<E  extends User,I> унаследовав его от Repository<E, I>
* В интерфейс UserRepository<E,I> задать абстрактный метод E findByFio (String fio)
* Создать класc StudentRepository имплементировав интерфейс UserRepository
 
**Задача 4**
  
* Создать класc StudentRepository имплементировав интерфейс UserRepository <Student, Integer>
* В классе StudentService добавить новую переменную StudentRepository 
* В классе StudentService  реализовать методы сохранения студента и его поиска по id и ФИО.

  
## Домашнее задание (семинар 4)
  
1. Реализовать класc TeacherRepository (обобщение на ваше усмотрение)
2. Обобщить интерфейс DataService, чтобы он работал только с наследникам класса User
3. Реализовать методы поиска и сохранения в классе TeacherService
4. Реализовать как можно более обобщенный интерфейс Controller
5. Создать классы StudentController, TeacherController, GroupController с методами сохранения и поиска соответствующих объектов
* Реализовать такой же функционал для класса GroupStream

## Семинар 5

**Задача 1**

* Создать пекедж terminal. Дальнейшие работы ведем в нем
* Создать интерфейс CommandParser c методом String[] parseCommand (String inputCommand)
* Cоздать класс TerminalReader, который содержит переменную CommandParser и метод, который в бесконечном цикле слушает команды с помощью Scanner(System.in)

**Задача 2**

* Сделать класс TerminalReader синглтоном

**Задача 3**

* Создать интерфейс CommandExecutable c абстрактным методом execute()
* Реализовать 2 класса, имплементировав созданный интерфейс, CreateStudentExecutable и DeleteStudentExecutable.
* В унаследованных методах они должны обращаться к методом класса StudentService.
* Подумать какие переменные могли бы содержать созданные классы

**Задача 4**

* Создать класc CommandExecutableFactory
* Реализовать в нём метод CommandExecutable create (String[] input), где в зависимости от переданных параметров создается тот или иной класс
* Осуществить этот класс и метод в классе TerminalReader

## Домашнее задание (семинар 5)

1. Повторить функционал с семинара №5
2. Реализовать команды для терминального клиента:
* удалить студента по имени
* удалить студента по номеру группы и возрасту
3. *Продумать логику отображения результата выполнения команды _(не реализовано)_

## Семинар 6

**Задача 1**
* Создать класс Command, который бы инкапсулировал в себе содержимое введенной команды
* Реализовать в нем булевские методы для проверки введенных команд
* Изменить сигнатуру у интерфейса ParseCommand, чтобы он вместо массива строк начал возвращать  объект класса Command
*  отредактировать класс CommandExecutableFactory, убрав из него хардкод и начав принимать на вход объект Command

**Задача 2**
* Создать класс LogingCommandExecutableFactory, наследующий класс CommandExecutableFactory
* Переопределить единственный метод так, чтобы он вызывал внутри себя метод предка, но в начале и конце распечатывал информацию о входных и выходных параметрах.

**Задача 3**
* Переименовать класс CommandExecutableFactory в CommandExecutableFactoryImpl
* Создать интерфейс CommandExecutableFactory и имплементировать от него класс CommandExecutableFactoryImpl
* В классе TerminalReader реализовать DIP, то есть возможность менять реализации CommandExecutableFactory

## Домашнее задание (семинар 6)
1. Повторить семинар задания с семинара 6
2. Проверить и отредактировать весь проект на предмет соответствия SOLID
3. Вместе с ссылкой указать, что вы поменяли и исходя из какого принципа
4. ** Продумать логику отображения результата выполнения команды

## Выполнение ДЗ семинара 6

1. **Пэкэдж controller**
* Переименовал классы GroupController и GroupStreamController в GroupControllerImpl и GroupStreamControllerImpl, соответственно.
* Реализовал два интерфейса GroupController и GroupStreamController, сделав абстрактными все методы, которые были реализованы без абстракций, в соответствии с Dependency Inversion Principle (Принцип инверсии зависимостей)
* Добавил метод create в интерфейс UserController, в соответствии с Принципом инверсии зависимостей (DIP)
* UserController – удалил public abstract, т.к. в интерфейсе методы по умолчанию public abstract

2. **Пэкэдж repository**
* StudentGroup - исправил в переопределении StudentGroup определение teacher и listOfStudent одной строкой

3. **Пэкэдж service**
* Для соблюдения принципа Dependency Inversion Principle (Принцип инверсии зависимостей) создал расширенные интерфейсы StudentService и TeacherService от DataService, т.к. данные классы имеют уникальные методы
* Не включил эти методы в существующий интерфейс DataService во избежание нарушения принципа Interface Segregation Principle (Принцип разделения интерфейса).

4. **Пэкэдж terminal**
* В CommandExecutableFactory, DelStudentByFioExecutable, DelStudentByAgeGroupExecutable добавил зависимости переменных через конструкторы в соответствии с принципом Dependency Inversion Principle (Принцип инверсии зависимостей).
* Корректировку на соответствие Single Responsibility Principle (Принцип единственной ответственности) произвел в рамках работы семинара 6, убрав хардкод из CommandExecutableFactory.

## Ссеминар 7

**Задача 1**

* Создать пекедж db
* Реализовать в нем абстрактный обобщенный класс Table, содержащий в себе переменную List<E> elements.
* Реализовать в классе метод добавления элемента E save(E entity), который внутри себя добавляет entity в переменную elements 

**Задача 2**

* Создать класс StudentTable 
* Реализовать метод удаления по имени boolean removeByName (String name), который бы удалял студента из таблицы по имени
* Создать в классе StudentRepository зависимость класса StudentTable 
* Вызывать метод removeByName из одноименного метода класса StudentRepository

**Задача 3**

* Создать реализацию CommandParser
 Чтобы разбить строку используйте метод split()
* Запустить приложение, вызвав метод класса TerminalReader, не забыв создать экземпляры зависимостей

## Домашнее задание (семинар 7)

1. Повторить задания 1,2 с семинара 7
2. Выполнить задание 3 с семинара 7
3. Реализовать метод save класса StudentRepository так, чтобы он в своем теле вызывал метод create класса StudentTable